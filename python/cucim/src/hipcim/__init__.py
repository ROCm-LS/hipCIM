#
# Copyright (c) 2025 Advanced Micro Devices, Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import sys as _sys

# generic
class _MirrorModule:
    def __init__(
        self, name, module, parent
    ):  # type: (_MirrorModule, str, _sys.ModuleType, (str|None)) -> None
        self.parent = parent  # type: _MirrorModule
        self.module = module  # type: _sys.ModuleType
        self.name = name  # type: str
        self.children = []  # type: list[_MirrorModule]

    @property
    def global_name(self):  # type: (_MirrorModule) -> str
        current = self
        result = [current.name]

        while current.parent is not None:
            current = current.parent
            result.append(current.name)

        return ".".join(reversed(result))

    def get_or_insert(
        self, name, module
    ):  # type: (_MirrorModule, str, _sys.ModuleType) -> _MirrorModule
        """Get child with the given name, create it if it doesn't exist."""
        assert module is not None
        for child in self.children:
            if child.name == name:
                return child

        new_child = _MirrorModule(name, module, parent=self)
        self.children.append(new_child)

        return new_child
 
    def walk(self):
        """Pre-order walk through self and descendants."""
        yield self

        for child in self.children:
            yield from child.walk()

    def register(self):
        """Add original module to registry and to parent's attributes under given name."""
        assert self.parent is not None
        _sys.modules[self.global_name] = self.module

        if not hasattr(self.parent.module, self.name):
            setattr(self.parent.module, self.name, self.module)

    def register_all_descendants(self):
        """Register descendants but not self."""
        for node in self.walk():
            if node != self:
                node.register()

# project-specific
def _variants(mod):
    "Project-specific package name variant generator."
    yield mod

    if "cucim" in mod:
        yield mod.replace("cucim", "hipcim")

    if "cuda" in mod:
        yield mod.replace("cuda", "hip")

# generic
def _descend(
    current, global_module_name_parts, lvl
):  # type: (_MirrorModule, list[str], int) -> None
    if lvl >= len(global_module_name_parts):
        return
    for v in _variants(global_module_name_parts[lvl]):
        _descend(
            current.get_or_insert(
                name=v,
                module=_sys.modules[
                    ".".join(global_module_name_parts[: lvl + 1])
                ],
            ),
            global_module_name_parts,
            lvl + 1,
        )

# project-specific
import cucim as _mirrored

__version__ = getattr(_mirrored, "__version__")
_root = _MirrorModule("hipcim", _mirrored, None)

for _key in _sys.modules.keys():
    if _key.startswith("cucim."):
        _descend(_root, _key.split("."), 1)
_root.register_all_descendants()

from cucim import *
_scm_version_string = None
__version_tuple__ = None 
try:
    # Import the version string generated by setuptools_scm as a temporary variable
    # Import the version tuple generated by setuptools_scm as the final __version_tuple__
    from .__version_tuple import version_tuple as __version_tuple__
except ImportError:
    # Fallback if _version.py hasn't been generated yet (e.g., during development)
    _scm_version_string = "0.0.0+scm_unknown"
    __version_tuple__ = (0, 0, 0, "scm_unknown", "unknown")

# generic
for _child in _root.children:
    globals()[_child.name] = _child.module

del _mirrored
del _descend
del _key
del _MirrorModule
del _root
del _child
del _sys
del _variants

__all__ = list(globals().keys())
