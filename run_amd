#!/bin/bash
# Copyright AMD CORPORATION.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

init_globals() {
    if [ "$0" != "/bin/bash" ]; then
        SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
        export RUN_SCRIPT_FILE="$(readlink -f "$0")"
    else
        export RUN_SCRIPT_FILE="$(readlink -f "${BASH_SOURCE[0]}")"
    fi

    #export TOP=$(git rev-parse --show-toplevel || $(dirname "${RUN_SCRIPT_FILE}"))
    export TOP=$(git rev-parse --show-toplevel 2>/dev/null || pwd) # pwd added for pipeline
    export AMDGPU_TARGETS=${AMDGPU_TARGETS:-"gfx942"}
}

################################################################################
# Utility functions
################################################################################

#######################################
# Get list of available commands from a given input file.
#
# Available commands and command summary are extracted by checking a pattern
# "_desc() { echo '".
# Section title is extracted by checking a pattern "# Section: ".
# This command is used for listing available commands in CLI.
#
# e.g.)
#   "# Section: String/IO functions"
#     => "# String/IO functions"
#   "to_lower_desc() { echo 'Convert to lower case"
#     => "to_lower ----------------- Convert to lower case"
#
# Arguments:
#   $1 - input file that defines commands
# Returns:
#   Print list of available commands from $1
#######################################
get_list_of_available_commands() {
    local file_name="$1"
    if [ ! -e "$1" ]; then
        echo "$1 doesn't exist!"
    fi

    local line_str='--------------------------------'
    local IFS= cmd_lines="$(IFS= cat "$1" | grep -E -e "^(([[:alpha:]_[:digit:]]+)_desc\(\)|# Section: )" | sed "s/_desc() *{ *echo '/ : /")"
    local line
    while IFS= read -r line; do
        local cmd=$(echo "$line" | cut -d":" -f1)
        local desc=$(echo "$line" | cut -d":" -f2-)
        if [ "$cmd" = "# Section" ]; then
            c_echo B "${desc}"
        else
            # there is no substring operation in 'sh' so use 'cut'
            local dash_line="$(echo "${line_str}" | cut -c ${#cmd}-)"  #  = "${line_str:${#cmd}}"
             c_echo Y "   ${cmd}" w " ${dash_line} ${desc}"
        fi
        # use <<EOF, not '<<<"$cmd_lines"' to be executable in sh
    done <<EOF
$cmd_lines
EOF
}

my_cat_prefix() {
    local IFS
    local prefix="$1"
    local line
    while IFS= read -r line; do
        echo "${prefix}${line}" # -e option doesn't work in 'sh' so disallow escaped characters
    done <&0
}


c_str() {
    local old_color=39
    local old_attr=0
    local color=39
    local attr=0
    local text=""
    #local no_change=0
    for i in "$@"; do
        case "$i" in
            r|R)
                color=31
                ;;
            g|G)
                color=32
                ;;
            y|Y)
                color=33
                ;;
            b|B)
                color=34
                ;;
            p|P)
                color=35
                ;;
            c|C)
                color=36
                ;;
            w|W)
                color=37
                ;;

            z|Z)
                color=0
                ;;
        esac
        case "$i" in
            l|L|R|G|Y|B|P|C|W)
                attr=1
                ;;
            n|N|r|g|y|b|p|c|w)
                attr=0
                ;;
            z|Z)
                attr=0
                ;;
            *)
                text="${text}$i"
        esac
        if [ ${old_color} -ne ${color} ] || [ ${old_attr} -ne ${attr} ]; then
            text="${text}\033[${attr};${color}m"
            old_color=$color
            old_attr=$attr
        fi
    done
    /bin/echo -en "$text"
}

c_echo() {
    local old_opt="$(shopt -op xtrace)" # save old xtrace option
    set +x # unset xtrace
    local text="$(c_str "$@")"
    /bin/echo -e "$text\033[0m"
    eval "${old_opt}" # restore old xtrace option
}


echo_err() {
    >&2 echo "$@"
}

c_echo_err() {
    >&2 c_echo "$@"
}

printf_err() {
    >&2 printf "$@"
}

get_item_ranges() {
    local indexes="$1"
    local list="$2"
    echo -n "$(echo "${list}" | xargs | cut -d " " -f "${indexes}")"
    return $?
}

get_unused_ports() {
    local num_of_ports=${1:-1}
    local start=${2:-49152}
    local end=${3:-61000}
    comm -23 \
    <(seq ${start} ${end} | sort) \
    <(ss -tan | awk '{print $4}' | while read line; do echo ${line##*\:}; done | grep '[0-9]\{1,5\}' | sort -u) \
    | shuf | tail -n ${num_of_ports} # use tail instead head to avoid broken pipe in VSCode terminal
}

newline() {
    echo
}

info() {
    c_echo W "$(date -u '+%Y-%m-%d %H:%M:%S') [INFO] " Z "$@"
}

error() {
    echo R "$(date -u '+%Y-%m-%d %H:%M:%S') [ERROR] " Z "$@"
}

fatal() {
    echo R "$(date -u '+%Y-%m-%d %H:%M:%S') [FATAL] " Z "$@"
    echo
    if [ -n "${SCRIPT_DIR}" ]; then
        exit 1
    fi
}

run_command() {
    local status=0
    local cmd="$*"

    c_echo B "$(date -u '+%Y-%m-%d %H:%M:%S') " W "\$ " G "${cmd}"

    [ "$(echo -n "$@")" = "" ] && return 1 # return 1 if there is no command available

    "$@"
    status=$?

    unset IFS

    return $status
}

retry() {
    local retries=$1
    shift

    local count=0
    until run_command "$@"; do
        exit=$?
        wait=$((2 ** count))
        count=$((count + 1))
        if [ $count -lt $retries ]; then
            info "Retry $count/$retries. Exit code=$exit, Retrying in $wait seconds..."
            sleep $wait
        else
            fatal "Retry $count/$retries. Exit code=$exit, no more retries left."
            return 1
        fi
    done
    return 0
}

get_arch() {
    local platform="${1:-$(uname -p)}"
    local platform_str

    case "${platform}" in
        amd64|x86_64|x86|linux/amd64)
            platform_str="x86_64"
            ;;
        arm64|aarch64|arm|linux/arm64)
            platform_str="aarch64"
            ;;
    esac

    echo -n "${platform_str}"
}

is_aarch64() {
    get_arch | grep -q "aarch64" && return 0 || return 1
}

is_x86_64() {
    get_arch | grep -q "x86_64" && return 0 || return 1
}

#==================================================================================
# Section: Build
#==================================================================================

build_local_libhipcim_() {
    local source_folder=${1:-${TOP}}
    local build_type=${2:-debug}
    local build_type_str=${3:-Debug}
    local prefix=${4:-}
    local build_folder=${source_folder}/build-${build_type}
    local CMAKE_CMD=${CMAKE_CMD:-cmake}

    pushd ${source_folder} > /dev/null

    export CMAKE_PREFIX_PATH=/opt/rocm/lib/cmake
    export CMAKE_MODULE_PATH=/opt/rocm/lib/cmake
    
    ${CMAKE_CMD} -S ${source_folder} -B ${build_folder} -G "Unix Makefiles" \
        -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE \
        -DCMAKE_PREFIX_PATH=${prefix} \
        -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
        -DCMAKE_BUILD_TYPE=${build_type_str} \
        -DCMAKE_INSTALL_PREFIX=${source_folder}/install \
        -DCMAKE_PREFIX_PATH=${prefix} \
        -DCMAKE_CXX_COMPILER=hipcc \
        -DGPU_TARGETS=${AMDGPU_TARGETS} 
        ${CMAKE_CMD} --build ${build_folder} --config ${build_type_str} --target hipcim -- -j $(nproc)
        ${CMAKE_CMD} --build ${build_folder} --config ${build_type_str} --target install -- -j $(nproc)

    popd
}

build_local_hipslide_() {
    local source_folder=${1:-${TOP}/cpp/plugins/cucim.kit.cuslide}
    local cucim_source_folder=${TOP}
    echo ${cucim_source_folder}
    local build_type=${2:-debug}
    local build_type_str=${3:-Debug}
    local prefix=${4:-}
    local build_folder=${source_folder}/build-${build_type}
    local CMAKE_CMD=${CMAKE_CMD:-cmake}

    pushd ${source_folder} > /dev/null
    export CMAKE_PREFIX_PATH=/opt/rocm/lib/cmake
    export CMAKE_MODULE_PATH=/opt/rocm/lib/cmake
    ${CMAKE_CMD} -S ${source_folder} -B ${build_folder} -G "Unix Makefiles" \
        -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE \
        -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
        -DCMAKE_BUILD_TYPE=${build_type_str} \
        -DCMAKE_PREFIX_PATH=${prefix} \
        -DCMAKE_C_COMPILER=hipcc \
        -DCMAKE_CXX_COMPILER=hipcc \
        -DCMAKE_INSTALL_PREFIX=${cucim_source_folder}/install

    ${CMAKE_CMD} --build ${build_folder} --config ${build_type_str} --target hipcim.kit.hipslide -- -j $(nproc)
    ${CMAKE_CMD} --build ${build_folder} --config ${build_type_str} --target install -- -j $(nproc)

    popd
}

build_local_hipmed_() {
    local source_folder=${1:-${TOP}/cpp/plugins/cucim.kit.cumed}
    local build_type=${2:-debug}
    local build_type_str=${3:-Debug}
    local prefix=${4:-}
    local build_folder=${source_folder}/build-${build_type}
    local CMAKE_CMD=${CMAKE_CMD:-cmake}
    local cucim_source_folder=${TOP}

    pushd ${source_folder} > /dev/null

    export CMAKE_PREFIX_PATH=/opt/rocm/lib/cmake
    export CMAKE_MODULE_PATH=/opt/rocm/lib/cmake
    ${CMAKE_CMD} -S ${source_folder} -B ${build_folder} -G "Unix Makefiles" \
        -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE \
        -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
        -DCMAKE_BUILD_TYPE=${build_type_str} \
        -DCMAKE_PREFIX_PATH=${prefix} \
        -DCMAKE_C_COMPILER=hipcc \
        -DCMAKE_CXX_COMPILER=hipcc \
        -DCMAKE_INSTALL_PREFIX=${cucim_source_folder}/install

    ${CMAKE_CMD} --build ${build_folder} --config ${build_type_str} --target hipcim.kit.hipmed -- -j $(nproc)
    ${CMAKE_CMD} --build ${build_folder} --config ${build_type_str} --target install -- -j $(nproc)

    popd
}

build_local_hipcim_() {
    local source_folder=${1:-${TOP}/python}
    local build_type=${2:-debug}
    local build_type_str=${3:-Debug}
    local prefix=${4:-}
    local build_folder=${source_folder}/build-${build_type}
    local CMAKE_CMD=${CMAKE_CMD:-cmake}

    pushd ${source_folder} > /dev/null

    local python_library=$(python3 -c "import distutils.sysconfig as sysconfig, os; print(os.path.join(sysconfig.get_config_var('LIBDIR'), sysconfig.get_config_var('LDLIBRARY')))")
    local python_include_dir=$(python3 -c "from distutils.sysconfig import get_python_inc; print(get_python_inc())")

    ${CMAKE_CMD} -S ${source_folder} -B ${build_folder} -G "Unix Makefiles" \
        -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE \
        -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
	-DCMAKE_BUILD_TYPE=${build_type_str} \
        -DCMAKE_PREFIX_PATH=${prefix} \
        -DCMAKE_INSTALL_PREFIX=${source_folder}/install \
        -DPYTHON_EXECUTABLE=$(which python3) \
        -DPYTHON_LIBRARY=${python_library} \
        -DPYTHON_INCLUDE_DIR=${python_include_dir}
    ${CMAKE_CMD} --build ${build_folder} --config ${build_type_str} --target hipcim -- -j $(nproc)
    ${CMAKE_CMD} --build ${build_folder} --config ${build_type_str} --target install -- -j $(nproc)

    popd
}

build_local_desc() { echo 'Build locally

Compile binaries locally

Arguments:
  $1 - subcommand [all|clean_cache|clean|cpp|libcucim|cuslide|cumed|cucim] (default: all)
  $2 - build type [debug|release|rel-debug] (default: debug)
'
}
build_local() {
    local subcommand="${1:-all}"
    local build_type="${2:-debug}"
    local build_type_str="Debug"
    local prefix=${3:-}

    local major_version="$(cat ${TOP}/HIPCIM_VERSION | cut -d. -f1)" # major version number

    [ "$build_type" = "debug" ] && build_type_str="Debug"
    [ "$build_type" = "release" ] && build_type_str="Release"
    [ "$build_type" = "rel-debug" ] && build_type_str="RelWithDebInfo"

    local old_opt="$(shopt -op errexit);$(shopt -op nounset)" # save old shopts
    set -eu

    if [ "$subcommand" = "clean_cache" ]; then
        rm -f ${TOP}/build-*/CMakeCache.txt
        rm -f ${TOP}/cpp/plugins/cucim.kit.cuslide/build-*/CMakeCache.txt
        rm -f ${TOP}/cpp/plugins/cucim.kit.cumed/build-*/CMakeCache.txt
        rm -f ${TOP}/python/build-*/CMakeCache.txt
    fi

    if [ "$subcommand" = "clean" ]; then
        rm -rf ${TOP}/build-*
        rm -rf ${TOP}/install
        rm -rf ${TOP}/cpp/plugins/cucim.kit.cuslide/build-*/
        rm -rf ${TOP}/cpp/plugins/cucim.kit.cuslide/install
        rm -rf ${TOP}/cpp/plugins/cucim.kit.cumed/build-*/
        rm -rf ${TOP}/cpp/plugins/cucim.kit.cumed/install
        rm -rf ${TOP}/python/build-*
        rm -rf ${TOP}/python/install
    fi

    if [ "$subcommand" = "cpp" ] ; then
        build_local_libhipcim_ ${TOP} ${build_type} ${build_type_str} ${prefix}
        build_local_hipslide_ ${TOP}/cpp/plugins/cucim.kit.cuslide ${build_type} ${build_type_str} ${prefix}
        build_local_hipmed_ ${TOP}/cpp/plugins/cucim.kit.cumed ${build_type} ${build_type_str} ${prefix}
    fi

    if [ "$subcommand" = "all" ] || [ "$subcommand" = "libhipcim" ]; then
        build_local_libhipcim_ ${TOP} ${build_type} ${build_type_str} ${prefix}
    fi

    if [ "$subcommand" = "all" ] || [ "$subcommand" = "hipslide" ]; then
        build_local_hipslide_ ${TOP}/cpp/plugins/cucim.kit.cuslide ${build_type} ${build_type_str} ${prefix}
    fi

    if [ "$subcommand" = "all" ] || [ "$subcommand" = "hipmed" ]; then
        build_local_hipmed_ ${TOP}/cpp/plugins/cucim.kit.cumed ${build_type} ${build_type_str} ${prefix}
    fi

    if [ "$subcommand" = "all" ] || [ "$subcommand" = "hipcim" ]; then
        build_local_hipcim_ ${TOP}/python ${build_type} ${build_type_str} ${prefix}
    fi

    # Remove existing library files at python/cucim/src/cucim/clara
    rm -f ${TOP}/python/cucim/src/cucim/clara/*.so*

    if [ "$subcommand" = "all" ] || [ "$subcommand" = "hipcim" ]; then
        # We don't need to copy binary if executed by conda-build
        if [ "${CONDA_BUILD:-}" != "1" ]; then
            # Copy .so files from libcucim & cuslide/cumed's build folders to cuCIM's Python source folder
            # Since wheel file doesn't support symbolic link (https://github.com/pypa/wheel/issues/203),
            # we don't need to copy symbolic links. Instead copy only libcucim.so.${major_version} (without symbolic link)
            cp ${TOP}/build-$build_type/lib/libhipcim.so.${major_version} ${TOP}/python/cucim/src/cucim/clara/
            cp -P ${TOP}/cpp/plugins/cucim.kit.cuslide/build-$build_type/lib/hipcim* ${TOP}/python/cucim/src/cucim/clara/
            cp -P ${TOP}/cpp/plugins/cucim.kit.cumed/build-$build_type/lib/hipcim* ${TOP}/python/cucim/src/cucim/clara/

            # Copy .so files from pybind's build folder to cuCIM's Python source folder
            cp ${TOP}/python/build-$build_type/lib/hipcim/_cucim.*.so ${TOP}/python/cucim/src/cucim/clara/
        fi
    fi

    eval "${old_opt}" # restore old shopts
}


#==================================================================================
# Section: Test
#==================================================================================

test_desc() { echo 'Execute test cases

Arguments:
  $1 - subcommand [all|python|cpp] (default: all)
  $2 - test_type [all|unit|integration|system|performance] (default: all)
  $3 - test_component [all|clara|skimage] (default: all)
'
}
test() {
    local subcommand="${1:-all}"
    local test_type="${2:-all}"
    shift;
    if [ "$subcommand" = "all" ] || [ "$subcommand" = "cpp" ]; then
        test_cpp "$@"
    fi

    if [ "$subcommand" = "all" ] || [ "$subcommand" = "python" ]; then
        test_python "$@"
    fi
}

install_python_test_deps_() {
    if [ -n "${CONDA_PREFIX}" ]; then
        # Install test dependencies from pip because conda does not have all the dependencies (e.g., opencv-python).
        # (https://github.com/rapidsai/cucim/pull/433)
        run_command pip install -r ${TOP}/python/cucim/requirements-test.txt
    else
        pushd "${TOP}/python/cucim"
        if [ -n "${VIRTUAL_ENV}" ]; then
            run_command pip3 install -e .[test]
        else
            run_command pip3 install --user -e .[test]
        fi
        popd
    fi
    hash -r
}

test_python_desc() { echo 'Execute Python test cases

Arguments:
  $1 - test_type [all|unit|integration|system|performance] (default: all)
  $2 - test_component [all|clara|skimage] (default: all)
'
}
test_python() {
    local test_type="${1:-all}"
    local test_component="${2:-all}"
    local result=0

    local testsuite=""
    local testsuite_unit_skimage="src"
    local testsuite_unit_clara="tests/unit"
    local testsuite_performance="tests/performance"

    if [ "$test_type" = "all" ] || [ "$test_type" = "unit" ]; then
        local testsuite="${testsuite_unit_skimage} ${testsuite_unit_clara}"
        [ "$test_component" = "skimage" ] && testsuite="${testsuite_unit_skimage}"
        [ "$test_component" = "clara" ] && testsuite="${testsuite_unit_clara}"

    fi
    if [ "$test_type" = "all" ] || [ "$test_type" = "performance" ]; then
        testsuite="${testsuite} ${testsuite_performance}"
    fi

    pushd $TOP/python/cucim
    run_command py.test --cache-clear -vv \
        --cov=cucim \
        --junitxml="$TOP/junit-cucim.xml" \
        --cov-config=$TOP/python/cucim/.coveragerc \
        --cov-report=xml:"$TOP/cucim-coverage.xml" \
        --cov-report term \
        ${testsuite}
    result=$?

    # Create comparison reports against baseline
    python3 $TOP/scripts/cucim_compare_junit.py                               \
         --baseline "$TOP/test_data/baseline/junit-cucim_latest.xml"          \
         --report "$TOP/junit-cucim.xml"                                      \
         --skip   "$TOP/test_data/baseline/junit-cucim_skiplist_latest.txt"   \
                                        > "$TOP/junit-cucim_report.txt" 2>&1
    info "JUnit comparison report written to \"$TOP/junit-cucim_report.txt\""

    python3 $TOP/scripts/cucim_compare_coverage.py                            \
         --baseline "$TOP/test_data/baseline/cucim-coverage_latest.xml"       \
         --report "$TOP/cucim-coverage.xml"                                   \
                                     > "$TOP/cucim-coverage_report.txt" 2>&1
    info "Coverage comparison report written to \"$TOP/cucim-coverage_report.txt\""

    popd

    return $result
}

test_cpp() {
	local install_dir=${TOP}/install
	local bin_dir=${install_dir}/bin
	# export library path
	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${install_dir}/lib
	# generate test images
	# source  test_data/gen_images.sh
	cd ${bin_dir}
	# link test data folder for source images
	ln -sf ../../test_data .
	# execute the tests 
	./cucim_benchmarks
	./cucim_primitives_benchmarks
	./cucim_tests
	./cumed_benchmarks
	./cumed_tests
	./cuslide_benchmarks
	./cuslide_tests
	./opj_compress -i test_data/image.pgm -o test_data/image.j2k
	./opj_decompress -i test_data/image.j2k -o test_data/image.pgm
	./opj_dump -i test_data/image.j2k
	./tiff_image test_data/private/generic_tiff_000.tif test_data/private
	#./tiff_image test_data/private/philips_tiff_000.tif test_data/private
	
}

#==================================================================================
# Section: Example
#==================================================================================

download_testdata_desc() { echo 'Download test data from Docker Hub
'
}
download_testdata() {
    c_echo W "Downloading test data..."
    run_command mkdir -p "${TOP}/notebooks/input"
    if [ ! -e "${TOP}/notebooks/input/image.tif" ]; then
        run_command rm -rf "${TOP}/notebooks/input"
        id=$(docker create gigony/svs-testdata:little-big)
        run_command docker cp $id:/input "${TOP}/notebooks"
        run_command docker rm -v $id
        c_echo G "Test data is downloaded to '${TOP}/notebooks/input'!"
    else
        c_echo G "Test data already exists at '${TOP}/notebooks/input'!"
    fi
}

#==================================================================================
# Section: Release
#==================================================================================

update_version_desc() { echo 'Update version

Executes ci/release/update-version.sh which updates some version-related
files based on VERSION file.

Returns:
  Outputs executed by update-version.sh

  Exit code:
    exit code returned from update-version.sh
'
}
update_version() {
    local new_version=${1:-}
    local ret=0
    [ -z "${new_version}" ] && c_echo_err R "Please specify '[new version]' (e.g., '21.06.00')!" && return 1
    $TOP/ci/release/update-version.sh "$@"
    ret=$?

    return $ret
}

parse_args() {
    local OPTIND
    while getopts 'yh' option;
    do
        case "${option}" in
            # a)
            #     VALUE=${OPTARG}
            #     ;;
            y)
                ALWAYS_YES=true;
                ;;
            h)
                print_usage
                exit 1
                ;;
            *)
                ;;
        esac
    done
    shift $((OPTIND-1))

    CMD="$1"
    shift

    ARGS=("$@")
}

print_usage() {
    set +x
    echo_err
    echo_err "USAGE: $0 [command] [arguments]..."
    echo_err ""
    c_echo_err W "Global Arguments"
    echo_err
    c_echo_err W "Command List"
    c_echo_err Y "    help  " w "----------------------------  Print detailed description for a given argument (command name)"
    echo_err "$(get_list_of_available_commands "${RUN_SCRIPT_FILE}" | my_cat_prefix " ")"
    echo_err
}

print_cmd_help_messages() {
    local cmd="$1"
    if [ -n "${cmd}" ]; then
        if type ${cmd}_desc > /dev/null 2>&1; then
            ${cmd}_desc
            exit 0
        else
            c_echo_err R "Command '${cmd}' doesn't exist!"
            exit 1
        fi
    fi
    print_usage
    return 0
}

install_cupy() {
    # Set default values for environment variables  
    CUPY_URL=${CUPY_URL:-"https://github.com/ROCm/cupy"}  
    CUPY_BRANCH=${CUPY_BRANCH:-"rocmds/develop/13.4.x"}  
    AMDGPU_TARGETS=${AMDGPU_TARGETS:-"gfx90a"}

    if [ -d "cupy" ]; then  
        echo "CuPy repository already exists. Updating instead of cloning..."  
        cd cupy  
        git fetch  
        git checkout $CUPY_BRANCH  
        git pull  
    else  
        echo "Cloning CuPy repository from $CUPY_URL..."    
        git clone $CUPY_URL || {    
            echo "ERROR: Failed to clone CuPy repository"    
            return 1    
        }  
        cd cupy  
        echo "Checking out branch $CUPY_BRANCH..."    
        git checkout $CUPY_BRANCH  
    fi
      
    echo "Installing ROCm dependencies..."  
    apt install -y hipblas hipsparse rocsparse rocrand hiprand rocthrust rocsolver rocfft hipfft hipcub rocprim rccl roctracer-dev  
      
    echo "Updating git submodules..."  
    git submodule update --init  
      
    echo "Upgrading pip..."  
    pip install --upgrade pip  
      
    echo "Setting up environment for CuPy build..."  
    export CUPY_INSTALL_USE_HIP=1  
    export ROCM_HOME=/opt/rocm  
    export HCC_AMDGPU_TARGET=${AMDGPU_TARGETS//;/,}  
      
    echo "Building CuPy wheel..."
    echo "Building CuPy wheel..."  
    python3 setup.py --cupy-package-name amd-cupy bdist_wheel || {  
        echo "ERROR: Failed to build CuPy wheel"  
        cd ..  
        return 1  
    }  
      
    echo "Installing CuPy wheel..."  
    CUPY_WHEEL=$(find ~+ -type f -name "*cupy*.whl")
    if [ -z "$CUPY_WHEEL" ]; then  
        echo "ERROR: Could not find CuPy wheel after build"  
        cd ..  
        return 1  
    fi  
    pip install ${CUPY_WHEEL} || {  
        echo "ERROR: Failed to install CuPy wheel"  
        cd ..  
        return 1  
    }    
      
    echo "CuPy installation completed successfully."  
    cd ..
    return 0  
}

install_dependencies() {
    c_echo B "Installing dependencies..."
    
    install_cupy
    if [ $? -ne 0 ]; then  
            echo "CuPy installation failed."  
            exit 1  
    fi
        
    c_echo G "Dependencies installed successfully!"
    return 0   
}

main() {
    local ret=0
    parse_args "$@"

    case "$CMD" in
        install_deps)
            install_dependencies "${ARGS[@]}"
            exit 0
            ;;
        help)
            print_cmd_help_messages "${ARGS[@]}"
            exit 0
            ;;
        ''|main)
            print_usage
            ;;
        *)
            if type ${CMD} > /dev/null 2>&1; then
                "$CMD" "${ARGS[@]}"
            else
                print_usage
                exit 1
            fi
            ;;
    esac
    ret=$?
    if [ -n "${SCRIPT_DIR}" ]; then
        exit $ret
    fi
}

init_globals

if [ -n "${SCRIPT_DIR}" ]; then
    main "$@"
fi


# Description template

# Globals:
#   CS_OS
#   CS_TARGET
#   CS_USER (used if CS_OS is "l4t")
#   CS_HOST (used if CS_OS is "l4t")
#   CS_OBSCURA_MODE (used in Obscura server)
# Arguments:
#   Command line to execute
# Returns:
#   Outputs print messages during the execution (stdout->stdout, stderr->stderr).

#   Note:
#     This command removes "\r" characters from stdout.

#   Exit code:
#     exit code returned from executing a given command
